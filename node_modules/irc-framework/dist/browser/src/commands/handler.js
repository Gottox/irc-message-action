'use strict';

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.reduce");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.create");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.get-prototype-of");

require("core-js/modules/es.object.set-prototype-of");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.iterator");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _ = {
  reduce: require('lodash/reduce'),
  find: require('lodash/find'),
  uniq: require('lodash/uniq')
};

var EventEmitter = require('eventemitter3');

var irc_numerics = require('./numerics');

var IrcCommand = require('./command');

module.exports =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(IrcCommandHandler, _EventEmitter);

  function IrcCommandHandler(connection, network_info) {
    var _this;

    _classCallCheck(this, IrcCommandHandler);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(IrcCommandHandler).call(this)); // Adds an 'all' event to .emit()

    _this.addAllEventName();

    _this.connection = connection;
    _this.network = network_info;
    _this.handlers = [];
    _this.request_extra_caps = [];

    require('./handlers/registration')(_assertThisInitialized(_this));

    require('./handlers/channel')(_assertThisInitialized(_this));

    require('./handlers/user')(_assertThisInitialized(_this));

    require('./handlers/messaging')(_assertThisInitialized(_this));

    require('./handlers/misc')(_assertThisInitialized(_this));

    require('./handlers/generics')(_assertThisInitialized(_this));

    return _this;
  }

  _createClass(IrcCommandHandler, [{
    key: "dispatch",
    value: function dispatch(message) {
      var irc_command = new IrcCommand(message.command.toUpperCase(), message); // Batched commands will be collected and executed as a transaction

      var batch_id = irc_command.getTag('batch');

      if (batch_id) {
        var cache = this.cache('batch.' + batch_id);

        if (cache) {
          cache.commands.push(irc_command);
        } else {// If we don't have this batch ID in cache, it either means that the
          // server hasn't sent the starting batch command or that the server
          // has already sent the end batch command.
        }
      } else {
        this.executeCommand(irc_command);
      }
    }
  }, {
    key: "executeCommand",
    value: function executeCommand(irc_command) {
      var command_name = irc_command.command; // Check if we have a numeric->command name- mapping for this command

      if (irc_numerics[irc_command.command.toUpperCase()]) {
        command_name = irc_numerics[irc_command.command.toUpperCase()];
      }

      if (this.handlers[command_name]) {
        this.handlers[command_name](irc_command, this);
      } else {
        this.emitUnknownCommand(irc_command);
      }
    }
  }, {
    key: "requestExtraCaps",
    value: function requestExtraCaps(cap) {
      this.request_extra_caps = _.uniq(this.request_extra_caps.concat(cap));
    }
  }, {
    key: "addHandler",
    value: function addHandler(command, handler) {
      if (typeof handler !== 'function') {
        return false;
      }

      this.handlers[command] = handler;
    }
  }, {
    key: "emitUnknownCommand",
    value: function emitUnknownCommand(command) {
      this.emit('unknown command', command);
    } // Adds an 'all' event to .emit()

  }, {
    key: "addAllEventName",
    value: function addAllEventName() {
      var original_emit = this.emit;

      this.emit = function () {
        var args = Array.prototype.slice.call(arguments, 0);
        original_emit.apply(this, ['all'].concat(args));
        original_emit.apply(this, args);
      };
    }
    /**
     * Convert a mode string such as '+k pass', or '-i' to a readable
     * format.
     * [ { mode: '+k', param: 'pass' } ]
     * [ { mode: '-i', param: null } ]
     */

  }, {
    key: "parseModeList",
    value: function parseModeList(mode_string, mode_params) {
      var chanmodes = this.network.options.CHANMODES || [];
      var prefixes = this.network.options.PREFIX || [];
      var always_param = (chanmodes[0] || '').concat(chanmodes[1] || '');
      var modes = [];
      var hasParam;
      var i;
      var j;
      var add;
      prefixes = _.reduce(prefixes, function (list, prefix) {
        list.push(prefix.mode);
        return list;
      }, []);
      always_param = always_param.split('').concat(prefixes);

      hasParam = function hasParam(mode, add) {
        var matchMode = function matchMode(m) {
          return m === mode;
        };

        if (_.find(always_param, matchMode)) {
          return true;
        }

        if (add && _.find((chanmodes[2] || '').split(''), matchMode)) {
          return true;
        }

        return false;
      };

      j = 0;

      for (i = 0; i < mode_string.length; i++) {
        switch (mode_string[i]) {
          case '+':
            add = true;
            break;

          case '-':
            add = false;
            break;

          default:
            if (hasParam(mode_string[i], add)) {
              modes.push({
                mode: (add ? '+' : '-') + mode_string[i],
                param: mode_params[j]
              });
              j++;
            } else {
              modes.push({
                mode: (add ? '+' : '-') + mode_string[i],
                param: null
              });
            }

        }
      }

      return modes;
    }
    /**
     * Cache object for commands buffering data before emitting them
     * eg.
     * var cache = this.cache('userlist');
     * cache.nicks = [];
     * cache.destroy();
     */

  }, {
    key: "cache",
    value: function cache(id) {
      var cache;
      this._caches = this._caches || Object.create(null);
      cache = this._caches[id];

      if (!cache) {
        var destroyCacheFn = function destroyCacheFn(cache, id) {
          return function () {
            delete cache[id];
          };
        }; // We don't want the destoryCache to be iterable


        cache = Object.defineProperty({}, 'destroy', {
          enumerable: false,
          configurable: false,
          value: destroyCacheFn(this._caches, id)
        });
        this._caches[id] = cache;
      }

      return cache;
    }
  }, {
    key: "hasCache",
    value: function hasCache(id) {
      return this._caches && Object.prototype.hasOwnProperty.call(this._caches, id);
    }
  }]);

  return IrcCommandHandler;
}(EventEmitter);